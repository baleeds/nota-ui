# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: RootQueryType
    mutation: RootMutationType
}

interface Node {
    "The id of the object."
    id: ID!
}

type Annotation implements Node {
    "The ID of an object"
    id: ID!
    insertedAt: DateTime!
    isFavorite: Boolean!
    numberOfFavorites: Int!
    numberOfReplies: Int!
    text: String!
    updatedAt: DateTime!
    user: User!
    userId: ID!
    verse: Verse!
    verseId: ID!
}

type AnnotationConnection {
    edges: [AnnotationEdge]
    pageInfo: PageInfo!
}

type AnnotationEdge {
    cursor: String
    node: Annotation
}

type AnnotationReply implements Node {
    annotation: Annotation!
    annotationId: ID!
    "The ID of an object"
    id: ID!
    insertedAt: DateTime!
    text: String!
    updatedAt: DateTime!
    user: User!
    userId: ID!
}

type AnnotationReplyConnection {
    edges: [AnnotationReplyEdge]
    pageInfo: PageInfo!
}

type AnnotationReplyEdge {
    cursor: String
    node: AnnotationReply
}

type CreateAccountPayload {
    "A list of failed validations. May be blank or null if mutation succeeded."
    messages: [ValidationMessage]
    "The object created/updated/deleted by the mutation. May be null if mutation failed."
    result: User
    "Indicates if the mutation completed successfully or not. "
    successful: Boolean!
}

type DeleteAnnotationPayload {
    "A list of failed validations. May be blank or null if mutation succeeded."
    messages: [ValidationMessage]
    "The object created/updated/deleted by the mutation. May be null if mutation failed."
    result: Boolean
    "Indicates if the mutation completed successfully or not. "
    successful: Boolean!
}

type DeleteAnnotationReplyPayload {
    "A list of failed validations. May be blank or null if mutation succeeded."
    messages: [ValidationMessage]
    "The object created/updated/deleted by the mutation. May be null if mutation failed."
    result: Boolean
    "Indicates if the mutation completed successfully or not. "
    successful: Boolean!
}

type FavoriteAnnotationPayload {
    "A list of failed validations. May be blank or null if mutation succeeded."
    messages: [ValidationMessage]
    "The object created/updated/deleted by the mutation. May be null if mutation failed."
    result: Annotation
    "Indicates if the mutation completed successfully or not. "
    successful: Boolean!
}

type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

type RefreshTokenPayload {
    "A list of failed validations. May be blank or null if mutation succeeded."
    messages: [ValidationMessage]
    "The object created/updated/deleted by the mutation. May be null if mutation failed."
    result: SessionInfo
    "Indicates if the mutation completed successfully or not. "
    successful: Boolean!
}

type ResetPasswordPayload {
    "A list of failed validations. May be blank or null if mutation succeeded."
    messages: [ValidationMessage]
    "The object created/updated/deleted by the mutation. May be null if mutation failed."
    result: Boolean
    "Indicates if the mutation completed successfully or not. "
    successful: Boolean!
}

type RootMutationType {
    createAccount(input: CreateAccountInput!): CreateAccountPayload!
    deleteAnnotation(annotationId: ID!): DeleteAnnotationPayload!
    deleteAnnotationReply(annotationReplyId: ID!): DeleteAnnotationReplyPayload!
    favoriteAnnotation(input: FavoriteAnnotationInput!): FavoriteAnnotationPayload!
    refreshToken(refreshToken: String!): RefreshTokenPayload!
    resetPassword(input: ResetPasswordInput!): ResetPasswordPayload!
    saveAnnotation(input: SaveAnnotationInput!): SaveAnnotationPayload!
    saveAnnotationReply(input: SaveAnnotationReplyInput!): SaveAnnotationReplyPayload!
    sendForgotPassword(input: SendForgotPasswordInput!): SendForgotPasswordPayload!
    signIn(input: SignInInput!): SignInPayload!
    signOut(refreshToken: String!): SignOutPayload!
    signOutEverywhere: SignOutPayload!
    unfavoriteAnnotation(input: UnfavoriteAnnotationInput!): UnfavoriteAnnotationPayload!
}

type RootQueryType {
    annotation(id: ID!): Annotation!
    annotationReplies(after: String, annotationId: ID, before: String, first: Int, last: Int): AnnotationReplyConnection
    favoriteAnnotations(after: String, before: String, first: Int, last: Int, userId: ID): AnnotationConnection
    me: User
    myAnnotations(after: String, before: String, first: Int, last: Int, verseId: ID): AnnotationConnection
    publicAnnotations(after: String, before: String, first: Int, last: Int, userId: ID, verseId: ID): AnnotationConnection
    user(id: ID!): User!
    verse(id: ID!): Verse!
    verses(bookNumber: Int!, chapterNumber: Int!): [Verse!]
}

type SaveAnnotationPayload {
    "A list of failed validations. May be blank or null if mutation succeeded."
    messages: [ValidationMessage]
    "The object created/updated/deleted by the mutation. May be null if mutation failed."
    result: Annotation
    "Indicates if the mutation completed successfully or not. "
    successful: Boolean!
}

type SaveAnnotationReplyPayload {
    "A list of failed validations. May be blank or null if mutation succeeded."
    messages: [ValidationMessage]
    "The object created/updated/deleted by the mutation. May be null if mutation failed."
    result: AnnotationReply
    "Indicates if the mutation completed successfully or not. "
    successful: Boolean!
}

type SendForgotPasswordPayload {
    "A list of failed validations. May be blank or null if mutation succeeded."
    messages: [ValidationMessage]
    "The object created/updated/deleted by the mutation. May be null if mutation failed."
    result: Boolean
    "Indicates if the mutation completed successfully or not. "
    successful: Boolean!
}

type SessionInfo {
    accessToken: String!
    refreshToken: String
    user: User!
    userId: ID
}

type SignInPayload {
    "A list of failed validations. May be blank or null if mutation succeeded."
    messages: [ValidationMessage]
    "The object created/updated/deleted by the mutation. May be null if mutation failed."
    result: SessionInfo
    "Indicates if the mutation completed successfully or not. "
    successful: Boolean!
}

type SignOutPayload {
    "A list of failed validations. May be blank or null if mutation succeeded."
    messages: [ValidationMessage]
    "The object created/updated/deleted by the mutation. May be null if mutation failed."
    result: Boolean
    "Indicates if the mutation completed successfully or not. "
    successful: Boolean!
}

type UnfavoriteAnnotationPayload {
    "A list of failed validations. May be blank or null if mutation succeeded."
    messages: [ValidationMessage]
    "The object created/updated/deleted by the mutation. May be null if mutation failed."
    result: Annotation
    "Indicates if the mutation completed successfully or not. "
    successful: Boolean!
}

type User implements Node {
    email: String!
    firstName: String
    "The ID of an object"
    id: ID!
    isAdmin: Boolean!
    lastName: String
}

"""

Validation messages are returned when mutation input does not meet the requirements.
While client-side validation is highly recommended to provide the best User Experience,
All inputs will always be validated server-side.

Some examples of validations are:

* Username must be at least 10 characters
* Email field does not contain an email address
* Birth Date is required

While GraphQL has support for required values, mutation data fields are always
set to optional in our API. This allows 'required field' messages
to be returned in the same manner as other validations. The only exceptions
are id fields, which may be required to perform updates or deletes.
"""
type ValidationMessage {
    "A unique error code for the type of validation used."
    code: String!
    """

    The input field that the error applies to. The field can be used to
    identify which field the error message should be displayed next to in the
    presentation layer.

    If there are multiple errors to display for a field, multiple validation
    messages will be in the result.

    This field may be null in cases where an error cannot be applied to a specific field.
    """
    field: String
    """

    A friendly error message, appropriate for display to the end user.

    The message is interpolated to include the appropriate variables.

    Example: `Username must be at least 10 characters`

    This message may change without notice, so we do not recommend you match against the text.
    Instead, use the *code* field for matching.
    """
    message: String
    "A list of substitutions to be applied to a validation message template"
    options: [ValidationOption]
    """

    A template used to generate the error message, with placeholders for option substiution.

    Example: `Username must be at least {count} characters`

    This message may change without notice, so we do not recommend you match against the text.
    Instead, use the *code* field for matching.
    """
    template: String
}

type ValidationOption {
    "The name of a variable to be subsituted in a validation message template"
    key: String!
    "The value of a variable to be substituted in a validation message template"
    value: String!
}

type Verse {
    bookNumber: Int!
    chapterNumber: Int!
    id: ID!
    text: String!
    verseNumber: Int!
}

input CreateAccountInput {
    email: String!
    firstName: String!
    lastName: String
    password: String!
}

input FavoriteAnnotationInput {
    annotationId: ID!
}

input ResetPasswordInput {
    password: String!
    token: String!
}

input SaveAnnotationInput {
    deletedAt: DateTime
    id: ID
    insertedAt: DateTime
    text: String!
    updatedAt: DateTime
    verseId: ID!
}

input SaveAnnotationReplyInput {
    annotationId: ID!
    id: ID
    text: String!
}

input SendForgotPasswordInput {
    email: String!
}

input SignInInput {
    email: String!
    password: String!
}

input UnfavoriteAnnotationInput {
    annotationId: ID!
}


"""
The `DateTime` scalar type represents a date and time in the UTC
timezone. The DateTime appears in a JSON response as an ISO8601 formatted
string, including UTC timezone ("Z"). The parsed date and time string will
be converted to UTC if there is an offset.
"""
scalar DateTime
